generator client {
    provider = "prisma-client-js"
    binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
    output = "/home/ubuntu/rise-as-one-manager/app/node_modules/.prisma/client"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// NextAuth.js required tables
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String    @unique
    emailVerified DateTime?
    image         String?
    password      String?
    role          String    @default("admin")
    accounts      Account[]
    sessions      Session[]
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// Main application tables
model Parent {
    id                 String        @id @default(cuid())
    name               String
    email              String        @unique
    phone              String?
    address            String?
    emergencyContact   String?
    emergencyPhone     String?
    stripeCustomerId   String?       @unique
    contractUrl        String?
    contractStatus     String        @default("pending") // pending, signed, expired
    contractUploadedAt DateTime?
    contractExpiresAt  DateTime?
    status             String        @default("active") // active, inactive, suspended
    notes              String?
    createdAt          DateTime      @default(now())
    updatedAt          DateTime      @updatedAt
    
    paymentPlans       PaymentPlan[]
    payments           Payment[]
    messageLogs        MessageLog[]
    
    @@index([email])
    @@index([status])
}

model PaymentPlan {
    id                   String    @id @default(cuid())
    parentId             String
    type                 String    // monthly, seasonal, custom, full
    totalAmount          Decimal   @db.Decimal(10, 2)
    installmentAmount    Decimal   @db.Decimal(10, 2)
    installments         Int
    startDate            DateTime
    nextDueDate          DateTime?
    status               String    @default("active") // active, paused, completed, cancelled
    stripeSubscriptionId String?   @unique
    stripePriceId        String?
    description          String?
    createdAt            DateTime  @default(now())
    updatedAt            DateTime  @updatedAt
    
    parent               Parent    @relation(fields: [parentId], references: [id], onDelete: Cascade)
    payments             Payment[]
    
    @@index([parentId])
    @@index([status])
    @@index([nextDueDate])
}

model Payment {
    id               String      @id @default(cuid())
    parentId         String
    paymentPlanId    String?
    dueDate          DateTime
    amount           Decimal     @db.Decimal(10, 2)
    status           String      @default("pending") // pending, paid, overdue, failed, refunded
    stripeInvoiceId  String?     @unique
    stripePaymentId  String?     @unique
    paidAt           DateTime?
    failureReason    String?
    remindersSent    Int         @default(0)
    lastReminderSent DateTime?
    notes            String?
    createdAt        DateTime    @default(now())
    updatedAt        DateTime    @updatedAt
    
    parent           Parent      @relation(fields: [parentId], references: [id], onDelete: Cascade)
    paymentPlan      PaymentPlan? @relation(fields: [paymentPlanId], references: [id], onDelete: SetNull)
    
    @@index([parentId])
    @@index([status])
    @@index([dueDate])
    @@index([stripeInvoiceId])
}

model Template {
    id              String       @id @default(cuid())
    name            String
    subject         String
    body            String       @db.Text
    category        String       @default("general") // general, payment, reminder, welcome, etc.
    channel         String       @default("email") // email, sms, both
    isAiGenerated   Boolean      @default(false)
    isActive        Boolean      @default(true)
    usageCount      Int          @default(0)
    variables       String[]     @default([]) // Template variables like {parentName}, {amount}, etc.
    createdAt       DateTime     @default(now())
    updatedAt       DateTime     @updatedAt
    
    messageLogs     MessageLog[]
    
    @@index([category])
    @@index([channel])
    @@index([isActive])
}

model MessageLog {
    id          String    @id @default(cuid())
    parentId    String
    templateId  String?
    subject     String?
    body        String    @db.Text
    channel     String    // email, sms
    status      String    @default("sent") // sent, failed, delivered, read
    sentAt      DateTime  @default(now())
    deliveredAt DateTime?
    readAt      DateTime?
    errorMessage String?
    metadata    Json?     // Additional data like email provider response, etc.
    
    parent      Parent    @relation(fields: [parentId], references: [id], onDelete: Cascade)
    template    Template? @relation(fields: [templateId], references: [id], onDelete: SetNull)
    
    @@index([parentId])
    @@index([channel])
    @@index([status])
    @@index([sentAt])
}

model SystemSettings {
    id          String   @id @default(cuid())
    key         String   @unique
    value       String   @db.Text
    description String?
    updatedAt   DateTime @updatedAt
    
    @@index([key])
}

model AuditLog {
    id          String   @id @default(cuid())
    userId      String?
    action      String
    entityType  String
    entityId    String
    oldValues   Json?
    newValues   Json?
    ipAddress   String?
    userAgent   String?
    createdAt   DateTime @default(now())
    
    @@index([userId])
    @@index([entityType])
    @@index([entityId])
    @@index([createdAt])
}
